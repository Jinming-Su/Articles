##C++深度探索
---

###运行栈和函数调用  
* **起源**： 全局变量在运行时是用唯一确定的地址进行定位的，存放在全局区（静态区，这部分内容可以去参照http://blog.csdn.net/u014451076/article/details/52927632，其中提到了内存分配中的全局区）。然而，对于局部变量却不是这样，原因如下：
    * 很多局部变量的生命周期远小于整个程序的运行周期，如果为每个局部变量分配不同的空间，则空间利用率降低
    * 递归程序中，每个局部变量在每层如果类似全局变量分配不同的地址，则需要分配大量的地址
    因此，函数形参和局部变量均不能想全局变量那样用固定的地址加以定位，而需要存储在一种特殊的结构中，那就是**栈**
* 运行栈实际上是一段区域的内存空间，与存储全局变量的空间无异，只是寻址的方式不同而已。
* 运行栈中的数据分为一个一个的栈帧，每个栈帧对应一次函数调用。栈帧中信息包括：形参、局部变量、控制信息和临时数据等（例如复杂表达式的中间值、返回值等）。一个函数在执行过程中可以直接随机访问它对应的栈帧中的数据。
* 当一个函数调用其他函数时，要为它所调用的函数设置形参，具体方式是在调用前吧形参值压入栈中，运行栈中的这一部分空间是主调函数和被调函数都可以直接访问的，参数的形实结合就是通过访问这一部分公共空间完成的。
* 在AI-32中有，栈指针esp和帧指针ebp的概念。帧指针是保存函数刚被调用时栈指针的位置的。
* <font color='red'>PS: 一个函数的原型信息（参数个数、参数类型和返回类型），并没有写在编译后的机器语言代码中，而是全部蕴含在这个函数所执行的操作之中。</font>

###位域  
* 位域是一种允许将类中的多个数据成员打包，从而时候不同成员可以共享相同的字节的机制。位域的定义方式：
    
    ```
    数据类型说明符 成员名：位数
    ```
* 注意：
    * C++标准虽然允许了这种打包机制但是并没有做明确规定，所以不同编译器中，包含位域的类所占用的空间可能有所不同
    * 只有bool,char,int,enum的成员可以被定义为位域
    * 位域虽然节省了内存空间，但是打包和捷豹任然需要耗费额外的操作时间
    
###用构造函数定义类型转换
* 隐式类型转换  
    `Line(Point(1), Point(4))` 
* 只允许显示执行的类型转换，通过在**类的声明处**(注意，不一定是定义的地方)添加explicit关键字来实现

###常成员函数声明原则
* 不改变对象状态的函数，都应声明为常成员函数；凡是会改变非静态成员对象的成员对象值的成员函数，都不能声明为常成员函数。
* 如果一个函数会改变某个成员对象的值，但它未必会改变对象状态。
* 举个例子：  
    一个Linu类，有属性：两个点，一个长度；有行为：求长度，通过getLen()得到长度，然后赋值给长度len。  
    这个过程中，getLen并不会改变对象状态，因为Line表示的线段是由两个点进行决定的，但是在语言上由于改变了len的值，不允许声明为常成员函数
* 为了解决上述问题，C++为这种情况提供了一个新的关键字mutable。对len使用mutable进行修饰，写成如下的形式
    
    ```
    class Line {
        public: 
            Line(xx)
            double getLen() const;
        private:
            Point p1,p2;
            mutable double len;
    }
    double Line:getLen() const {
        xxx
    }
    ```

###指针和引用
* 指针是C语言本身就有的一个特性,C++在继承C语言指针的同时，引入了引用
* 普通指针可以多次被赋值，但是引用只能在初始化时指定被引用的对象，其后就不能更改了。因此，引用的功能和一个指针常量差不多。
* **只有常引用，而没有引用常量**。也就是说，不能用T & const 作为引用类型　　　　　　　　　　　　　　

###运行时类型识别
* 需求：使用基类指针无法调用派生类中新加入的成员，需要进行基类向派生类的转换
* 两种机制
    * dynamic_cast  
    dynamic_cast可以将基类的指针显示转化为派生类的指针，或将基类的引用显示转化为派生类的引用
    * typeid获取运行时类型信息
    typeid是C++的一个关键字，可以获得一个类型的相关信息。通过typeid(表达式或者类型说明符)得到的是一个type_info类型的常引用。type_info是C++标准库中的一个类，专用于在运行时表示类型信息，定义在typeinfo头文件中。type_info类有一个name函数，用来获取类型的名称。
